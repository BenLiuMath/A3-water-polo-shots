<!DOCTYPE HTML>
<html xml:lang="en" lang="en">
<head>
  <title>CSE512 | A3 Women's Water Polo Offense Visualizer</title>
  <style media="all">
* { padding: 0; margin: 0; }

body {
	margin: 0 auto 0 auto;
	padding: 0;
	max-width: 1200px;
	font-family: "Avenir", "Avenir Next", Helvetica Neue, Arial;
	font-size: 0.95em;
}

a, a:visited { text-decoration: none; color: #7533f4; }
a:hover { text-decoration: underline; color: #f4b014; }

ol {
	margin-left: 30px;
	padding: 15 15 15px 15;
}

ol li
{
    text-indent: 5px;
    margin: 5px 0;
}

/* ul{
	margin-left: 30px;
	padding: 15 15 5px 15;
}

ul li
{
    margin: 0px;
    padding: 0px;
    text-indent: 10px;
} */

ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
}

h1, h2, h3, h4, h5 {
	color: #492a7c;
	background-color: inherit;
	font-weight: normal;
	padding: 0 0 5px 0;
	margin: 15px 0 0 0;
	border: none;
	clear: right;
}
h1 { font-size: 24pt; margin:  5px 0 10px 0; line-height: 28px; }
h2 { font-size: 14pt; margin: 30px 0 15px 0; letter-spacing: 0.01em; border-bottom: 1px solid #ccc;  line-height: 20px;}
h3 { font-size: 13pt; }
h4 { font-size: 12pt; }
h5 { font-size: 11pt; }
p { margin: 0 0 10px 0; }

.content {
	margin: 0;
	padding: 15px 20px;
	background-color: #ffffff;
}

.title, .title h1, .title a {
	color: #492a7c;
	font-size: 20pt;
	margin-bottom: 20px;
	margin-top: 5px;
}

.instructions {
  color: #492a7c;
  font-size: 11pt;
  margin-bottom: 10px;
  margin-top: 10px;
}

.footer {
	border-top: 1px solid #ccc;
	margin-top: 30px;
	padding-top: 4px;
	text-align: right;
	font-size: 12px;
}
.footer a {
	color: #21346B;
}
.footer a:hover {
	color: #ce3333;
}
  </style>
<style>
body {
	font: 11px sans-serif;
	font-family: Tahoma;
	margin:0px;
}

#sidebar h1{
	font-size: 18pt;
}

.axis {
	font-size:10pt;
}
.axis path,
.axis line {
	fill: none;
	stroke: #000;
	shape-rendering: crispEdges;
}

.axisLabel {
	font-size:12pt;
	fill: black;
	opacity: 1.0;
}

/* Shot Icons */
.shotIcon {
	shape-rendering: geometricPrecision;
	stroke-width:1.5px;
}
.shotIconFocalTeam {
    stroke:#4056a1;
    fill:#4056a1;
}
.shotIconOpponentTeam {
    stroke:#F4634D;
    fill:#F4634D;
}
.shotIconFocalPlayer {
    stroke: #CCAA00;
    fill: #CCAA00;
}
.shotIconMiss {
    fill:transparent !important;
}

.ratioLine {
	stroke: rosybrown;
	shape-rendering: crispEdges;
	stroke-width:4px;
}

.scatterdot {
	stroke: none;
	//fill: darkblue;
	opacity:.55;
	shape-rendering: geometricPrecision;
}

.legend {
	background-color: coral;
}

.scatterdotLegend {
	stroke: none;
	fill: darkblue;
	opacity:.55;
	shape-rendering: geometricPrecision;
}

.teamnameThis, .teamnameOpponent {
	font-size:12pt;
	font-weight:bold;
	font-style:italic;
}

.finalScoreThis {
	font-size:12pt;
	font-weight:bold;
	fill: #4056a1;
}

.finalScoreOpponent {
	font-size:12pt;
	font-weight:bold;
	fill: #f13c20;
	opacity:0.8;
}

.tooltip {
	position: absolute;
	background: cornsilk;
	pointer-events: none;
	padding:5px;
	border: BlanchedAlmond 1px solid;
}

.areaWin {
	fill: #4056a1;
	opacity:.25;
}

.areaLose {
	fill: #f13c20;
	opacity: .25;
}

#welcome {
	position:absolute;
	top:400px;
	left:20px;
	line-height:200px;
	width:770px;
	height:200px;
	text-align:center;
	font-size:36pt;
	background:lightgray;
}

#roster { font-size:10pt; }
#roster input {
    opacity:0.5;
    display:none;
}

#roster ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
}
#roster li {
	text-indent: 0px;
}

#roster label {
    cursor:pointer;
    display:inline;
}
#roster label:hover {
    color:#4056a1;
}
#roster label::before{
    display:inline-block;
    width:15px;
    content: " ";
}
#roster input[type=checkbox]:checked + label::before {
    content: "\25CF";
    color:#CCAA00;
}
</style>
</head>
<body>
<div class="content">
<section class="title">
<a href="#">Women's Water Polo Offense Visualizer - <i>2017 FINA World Championships</i></a>
</section>

<section>
<svg id="poloVis"></svg>

<div id="sidebar" style="display:inline-block; vertical-align:top; ">

<br>
<svg id="legends"></svg>

<!-- <h1>Women's Water Polo</h1>
<h3>2017 FINA World Championships</h3> -->
<!-- <br/> -->
<section class="instructions">
Select a team:
</section>
<!-- <br/><br/> -->
<select id="teamSelector"></select>
<section class="instructions">
and click on one or more timelines <br/>(to the left) to view data for those<br/>games.
<!-- </section>

<section class="instructions"> -->
<br><br>
<i>Hover over data points for details!</i>
<br><br>
You can also select a player <br/>to highlight their contributions:
</section>

<!-- <br/><br/>
Select a player to highlight their contributions:
<br/><br/> -->
<div id="roster"></div>

<br/>
<hr>
<br/>

<section>
  <p>
    <strong>Designed &amp; Built By</strong>: Brian DeSilva, Abe<br/>Engle, Ben Liu, and Kellie MacPhee.
  </p>
</section>

<section>
  <p>
    <strong>Data Source</strong>: <a href="http://www.omegatiming.com/Sport?sport=AQ">Omega Timing</a>
  </p>
</section>

</div>


<div id="welcome">
Click a timeline to get started!
</div>

<script src="https://d3js.org/d3.v4.min.js"></script>

<script>

var teamCodes = ["FRA","USA","ESP","NED","CHN","AUS","GRE","CAN","KAZ","NZL","JPN","HUN","RSA","ITA","RUS","BRA"];
var teamDecodes = {
"FRA":"France",
"USA":"United States",
"ESP":"Spain",
"NED":"Netherlands",
"CHN":"China",
"AUS":"Australia",
"GRE":"Greenland",
"CAN":"Canada",
"KAZ":"Kazakhstan",
"NZL":"New Zealand",
"JPN":"Japan",
"HUN":"Hungary",
"RSA":"South Africa",
"ITA":"Italy",
"RUS":"Russia",
"BRA":"Brazil"
};
var allPoloDatas = [];
var allShotSummaryDatas = [];


// data and lookup
var shotTypes = ["Total","Action shot","Centre shot","5m shot","Extra player shot"];
var shotTypesDecode = ["All Shots","Action Shots","Centre Shots","Shots Outside 5m","Extra Player Shots"];

var imgPath = "img/";

//var allPoloDatas = [poloDataUSA, poloDataBRA, poloDataESP];
//var allShotSummaryDatas = [shotSummaryUSA, shotSummaryBRA, shotSummaryESP];

// Sizing and Styling
{
var marginTimeline = {top:0, right: 80, bottom:0, left:110};
var marginScatter = {top:30, right: 80, bottom:50, left:70};


var scatterWidth, scatterHeight;
var scatterTimelinePadding = 130;

var scatterAxesPositions = [[0,   0,   280, 210],
							[340, 0,   140, 80],
							[340, 130, 140, 80],
							[540, 0,   140, 80],
							[540, 130, 140, 80]];
scatterHeight = scatterAxesPositions[0][3];
scatterWidth = scatterAxesPositions[4][2] + scatterAxesPositions[4][3];

var scatterOuterBoxHeight = scatterHeight + marginScatter.top + marginScatter.bottom;
var scatterOuterBoxWidth = marginScatter.left + marginScatter.right + scatterWidth;

var timelineHeight = 50;
var timelineQuarterWidth = 140;
var timelineInternalPadding = 20;
var timelineVerticalPadding = 5;
var timelineWidth = 4*timelineQuarterWidth + 3*timelineInternalPadding;

var timelineOuterBoxHeight = marginTimeline.top + marginTimeline.bottom + (timelineHeight+timelineVerticalPadding)*6;
var timelineOuterBoxWidth = marginTimeline.left + marginTimeline.right + timelineWidth;

var widthFull = Math.max(scatterOuterBoxWidth, timelineOuterBoxWidth)

var heightFull = scatterOuterBoxHeight + marginTimeline.top+marginTimeline.bottom + timelineOuterBoxHeight + 20;


// var USAColor = "darkblue";
// var OpponentColor = "#999999";
}


/**
* Elements
*/
{
var teamSelect = document.getElementById("teamSelector");

var svg = d3.select("#poloVis")
    .attr("width", widthFull)
    .attr("height", heightFull)
	//.attr("style","background:red;")
	.append("g")
    .attr("transform", `translate(0, 0)`);

var svgLegend = d3.select("#legends")
    .attr("width", 220)
    .attr("height", 100)
	//.attr("style","background:red;")
	.append("g")
    .attr("transform", "translate(" + 10 + "," + (marginScatter.top - 20) + ")");

// var title =  svg.append("text")
//             .attr("x", (widthFull / 2) - margin.left)
//             .attr("y", -20)
//             .attr("text-anchor", "middle")
//             .style("font-size", "32px")
//             .text("Women's Water Polo at the 2017 FINA World Championships");

var tooltip = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

}

/**
* State
*/
{
var currTeam = 0;
var currTeamCode = teamCodes[currTeam];

var numGames = 0;
var gameFilter = [0,0,0,0,0,0];

var poloData;
var shotData;

//console.log(JSON.stringify(shotData).replace(/},{/g,"},\n\n{"));
var playerSelectOpts = {};
var players = [];
var playerFilter = [];
}

/**
* Initialize data and state variables
*/
{
function initializeData(newTeam) {
	playerFilter = [];
	currTeam = newTeam;
	currTeamCode = teamCodes[newTeam];
	poloData = allPoloDatas[newTeam];
	shotData = allShotSummaryDatas[newTeam];
	numGames = d3.max(poloData.map( (d) => { return d.Game; }));

	players = d3.nest()
	.key( (d) => { return d.Player; } )
	.entries(shotData)
	.map( (d) => {
		return d.key;
	});
	populateSelectors();
}

function populateSelectors() {

	var roster = document.getElementById("roster");
	roster.innerHTML = "";
    var ul = document.createElement("ul");
    roster.append(ul);

	players.forEach( function(player) {

        var li = document.createElement("li");
        var check = document.createElement("input");
        check.type="checkbox";
        check.id="toggle"+player;
        li.appendChild(check);
        var lab = document.createElement("label");
        lab.htmlFor="toggle"+player;
        lab.appendChild(document.createTextNode(toTitleCase(player)));
        lab.addEventListener("click", function() {
			togglePlayer(player);
		});
        li.appendChild(lab);
        ul.appendChild(li);
	});
}
}

/**
* Data filtering and processing functions
*/
{
function toTitleCase(text) {
  // Assumes data comes in the form "LASTNAME FIRSTINITIAL"
  [token1, token2, token3] = text.split(" ")
  if(token3)
  {
    return token3.charAt(0).toUpperCase() + ". " + token2.charAt(0).toUpperCase() + token2.substr(1).toLowerCase()
            + " " + token1.charAt(0).toUpperCase() + token1.substr(1).toLowerCase();
  }
  else {
    return token2.charAt(0).toUpperCase() + ". " + token1.charAt(0).toUpperCase() + token1.substr(1).toLowerCase();
  }
}

function aggregateShotDataByPlayer(data) {
	var shotDataAggregatedByPlayer = d3.nest()
	.key( (d) => { return d.Player; } )
	.rollup( (v) => { var obj = {};
		shotTypes.forEach( (mykey) => {
			obj[mykey+" attempted"] = d3.sum(v, (d) => { return d[mykey+" attempted"]; });
			obj[mykey+" made"] = d3.sum(v, (d) => { return d[mykey+" made"]; });
		})
		return obj;
		})
	.entries(data)
	.map( (d) => {
		var obj = d.value;
		obj.Player = d.key;
		return obj;
	});
	return shotDataAggregatedByPlayer;
}

function groupPlayerShotStatistics(data,shotType) {
	var shotDataGrouped = d3.nest()
	.key( (d) => { return [d[shotType+" attempted"],d[shotType+" made"]]; } )
	.rollup( (v) => {
		var res = [];
		v.forEach(function(e) { res.push(e.Player); })
		return res;
	})
	.entries(data)
	.map((e) => { var obj = {};
		var coord = e.key; coord = coord.split(",");
		coord[0] = parseInt(coord[0]);
		coord[1] = parseInt(coord[1]);
		obj.coord = coord;
		var players = e.value;
		obj.players = players;
		obj.numPlayers = players.length;
		return obj;
	});
	return shotDataGrouped;
}
}

/**
* Scatter charts
*/
{
// probability function for plotting y-values on the charts

var scatterCharts = [];
var scatterGroup = svg.append("g")
	.attr("transform", `translate(${marginScatter.left}, ${marginScatter.top})`);

function initializeScatterCharts() {
	for(var nn=0; nn<5; nn++) {

		var mypos = scatterAxesPositions[nn];
		var xoff = mypos[0];
		var yoff = mypos[1];
		var mywidth = mypos[2];
		var myheight = mypos[3];

		// shot function for plotting x-vlaues on the charts
		var shots = d3.scaleLinear().rangeRound([0, mywidth]);
			//.domain(lim);

		var scatterChart = scatterGroup.append("g")
			.attr("class", "scatterChart")
			.attr("width", mypos[2])
			.attr("height", mypos[3])
			.attr("transform", `translate(${xoff}, ${yoff})`);

		scatterChart.append("g")
			.attr("class", "axis axisX")
			.attr("transform", `translate(0, ${myheight})`)
			.call(d3.axisBottom(shots)
				.tickFormat(d3.format("d"))
				.ticks(0).tickSizeOuter(0));

		scatterChart.append("text")
			.attr("class","axisLabel")
			.attr("transform",`translate(${mywidth/2},0)`)
			.attr("dy","-.1em")
			.style("text-anchor", "middle")
			.text(shotTypesDecode[nn]);

		var probability = d3.scaleLinear().rangeRound([myheight,0])
			.domain([-.1, 1.1]);

		scatterCharts[nn] = [scatterChart,probability];

		// Label first y-axis and give ticks
		var averageLines = scatterChart.selectAll(".ratioLine")
            .data([{"ratio":0}])  // data is a singleton array with # shots made / # shots
            .enter()
            .append("line")
            .attr("class","ratioLine")
			.attr("x1",0)
			.attr("x2",mywidth)
			.attr("y1",0)
			.attr("y2",0);

		if(nn === 0) {
			scatterChart.append("g")
				.attr("class", "axis axis--y")
				.call(d3.axisLeft(probability)
					.ticks(3)
					.tickFormat(d3.format(".0%"))
					.tickSizeOuter(0));

			scatterChart.append("text")
			.attr("class", "axisLabel")
			.attr("transform", "rotate(-90)")
				  .attr("y",-65)
				  .attr("x",0 - (myheight / 2))
				  .attr("dy", "1em")
				  .style("text-anchor", "middle")
				  .text("Success");
		} else {
			scatterChart.append("g")
				.attr("class", "axis axis--y")
				.call(d3.axisLeft(probability).ticks(3)
					.tickFormat(d3.format(".0%")).tickSizeOuter(0));
		}
		//console.log(JSON.stringify(mydata).replace(/},{/g,"},\n\n{"));
	}

	//  Scatterplot legend
	var scatterLegendVals = [1,2,4];
	scatterLegend = svgLegend.append("g")
	  // .attr("class", " ")
	  .attr("width", mywidth/3)
	  .attr("height", myheight)
	  .attr("transform", `translate(${0}, 0)`);

	for(var nn=0; nn<scatterLegendVals.length; nn++) {
		scatterLegend.append("circle")
		.attr("class", "scatterdotLegend")
		.attr("r",4*Math.sqrt(scatterLegendVals[nn]))
		.attr("transform", `translate(0,${nn*20})`);

			if(scatterLegendVals[nn]===1) {
			scatterLegend.append("text")
			// .attr("class","axisLabel")
			.attr("transform",
			  "translate(" + (mywidth/6 + 15) + " ," +
					   (nn*20-18) + ")")
			.attr("dy","2em")
			.style("text-anchor", "middle")
			.text(scatterLegendVals[nn] + " player");
		  } else {
			scatterLegend.append("text")
			// .attr("class","axisLabel")
			.attr("transform",
			  "translate(" + (mywidth/6 + 15) + " ," +
					   (nn*20-18) + ")")
			.attr("dy","2em")
			.style("text-anchor", "middle")
			.text(scatterLegendVals[nn] + " players");
		  }
		}

		scatterLegend.append("path")
			.attr("class","ratioLine")
			// draw a line at (0, ratio) to (x-axis-length, ratio)
			.attr("transform", `translate(0,${10+scatterLegendVals.length*20})`)
			.attr("d", "M " + -7 + " " + 0 + " L " + 7+ " " + 0);

		scatterLegend.append("text")
			.attr("transform",
			"translate(" + (mywidth/6 + 25) + " ," +
					 (10+scatterLegendVals.length*20-18) + ")")
			.attr("dy","2em")
			.attr("dx", "1.5em")
			.style("text-anchor", "middle")
			.text("Team Avg.");
		scatterLegend.append("image")
			.attr("id", "legendPicture")
			.attr("href", imgPath + currTeamCode + ".png")
			.attr("height", "10px")
			.attr("width", "16.6px")
			.attr("x", 15)
			.attr("y", 65);
}

function populateScatterPlots() {

// Iterate over each of the scatterplots
for(var nn=0; nn<scatterCharts.length; nn++) {
	var chart = scatterCharts[nn][0];

	// get data
	var myShotData = aggregateShotDataByPlayer(shotData.filter((d) => { return gameFilter[d.Game-1]; }));
	var myGroupedData = groupPlayerShotStatistics(myShotData,shotTypes[nn]);
	var myData = myGroupedData.filter( (d) => {
			return d.coord[0]>0;
		});

	// Update axis limits
	var shotextent = d3.extent(myData, (d) => { return d.coord[0];});
	shotextent[0] = Math.min(shotextent[0],0);

	var shotrange = shotextent[1] - shotextent[0];
	var lim = [shotextent[0]-.15*shotrange, shotextent[1]+.15*shotrange];

	// Establish y-scale
	var shots = d3.scaleLinear()
		.rangeRound([0, scatterAxesPositions[nn][2]])
		.domain(lim);


	chart.select(".axisX")
		.transition()
        .duration(200)
		.call(d3.axisBottom(shots)
			.tickFormat(d3.format("d")).ticks(2).tickSizeOuter(0));

    // Average lines
    var totalShotsMade = 0;
    var totalShotsAttempted = 0;
    var maxShotsMade = 1;
    for (var i = myData.length - 1; i >= 0; i--) {
        if (maxShotsMade < myData[i].coord[0]) {
            maxShotsMade = myData[i].coord[0];
        }
        totalShotsMade += myData[i].coord[0];
        totalShotsAttempted += myData[i].coord[1];
    }
	var probability = scatterCharts[nn][1];
    // Remove existing lines
    //console.log(totalShotsMade);
    if(totalShotsMade>0) {
		ratios =  totalShotsAttempted / totalShotsMade;

        var averageLines = chart.selectAll(".ratioLine")
            .data([{"ratio":ratios}])
            .on("mouseover", function(d) {
                tooltip.transition()
                .duration(200)
                .style("opacity", 1.0);
                tooltip.html("Team: " + (100*d.ratio).toFixed(2) + "%")
                .style("left", (d3.event.pageX +2) + "px")
                .style("top", (d3.event.pageY -20) + "px");
            })
            .on("mouseout", function(d) {
                tooltip.transition()
                .duration(500)
                .style("opacity", 0);
            })
			.transition() // data is a singleton array with # shots made / # shots
			.attr("y1", (d) => { return probability(d.ratio); } )
			.attr("y2", (d) => { return probability(d.ratio); } )
			.style("opacity", 1.0)
    } else {
		chart.selectAll(".ratioLine")
			.style("opacity", 0.0)
	}


	function tooltipShow(d) {
		tooltip.transition()
            .duration(200)
            .style("opacity", 1.0);
            tooltip.html("Made: " + d.coord[1]+"/"+d.coord[0]+'<ul><li>' + d.players.map(toTitleCase).join('</li><li>')+"</li></ul>")
            .style("left", (d3.event.pageX + 5) + "px")
            .style("top", (d3.event.pageY - 28) + "px");
	}
	function tooltipHide(d) {
			tooltip.transition()
			.duration(500)
			.style("opacity", 0);
		}

    chart.selectAll(".scatterdot")
        .attr("class","dotsToRemove")
        .transition()
        .duration(200)
        .style("opacity",0)
		.remove();

    var mydots = chart.selectAll(".scatterdot")
		.data(myData)

	mydots.enter()
		.append("circle")
        .style("opacity",0)
		.attr("class", "scatterdot")
		.attr("r", (d) => { return 4*Math.sqrt(d.numPlayers); })
		.attr("cx", (d) => {
			return shots(d.coord[0]);
		})
		.attr("cy", (d) => {
			return probability(d.coord[1]/d.coord[0]);
		})
		.on("mouseover", tooltipShow)
		.on("mouseout", tooltipHide)
		.attr("fill", (d) => {
			if(d.players.filter( (p) => { return playerFilter.includes(p);	}).length>0) {
				return "#CCAA00";
			} else {
				return "darkblue";
			}})
        .transition()
        .delay(100)
        .duration(200)
        .style("opacity",0.55);
}
}

function filterScatterPlots() {
for(var nn=0; nn<shotTypes.length; nn++) {
	var chart = scatterCharts[nn][0];

    var mydots = chart.selectAll(".scatterdot")
        .transition(d3.easeElasticOut(200))
		.attr("fill", (d) => {
			if(d.players.filter( (p) => { return playerFilter.includes(p);	}).length>0) {
				return "#CCAA00";
			} else {
				return "darkblue";
			}});
}
}
}

/**
* Timelines
*/
{
var shotIconDisplayLevel = .25;

var gameTime = d3.scaleLinear()
	.rangeRound([0, timelineWidth])
	.domain([0,8.0*60.0*4.0]);
var quarterTime = d3.scaleLinear()
	.rangeRound([0, timelineQuarterWidth])
	.domain([8*60,0]);

var success = d3.scaleLinear()
    .rangeRound([timelineHeight,0])
    .domain([-1,1]);

var timelines = [];
var quarters = [];
var timelineGroup = svg.append("g")
	.attr("transform", `translate(${marginTimeline.left}, ${scatterOuterBoxHeight+marginTimeline.top})`);

function initializeTimelines() {
	// Quarter labels
	for(var quarterNum=1; quarterNum<=4; quarterNum++) {
		timelineGroup.append("text")
			.attr("class","axisLabel")
			.attr("y",0)
			.attr("x",timelineQuarterWidth/2 + (quarterNum-1)*(timelineQuarterWidth+timelineInternalPadding))
			.attr("dy","-.5em")
			.style("text-anchor", "middle")
			.text("Quarter "+quarterNum);
	}

//  Timeline legend

var timelineLegend = svgLegend.append("g")
  // .attr("class", "legend")
  // .attr("width", timelineWidth)
  // .attr("height", timelineHeight)
  .attr("transform", `translate(${120}, 0)`);

  var timelineLegendVertSpace = 17;
  var timelineLegendVertStart = -19;
  var timelineLegendHorizSpace = 45;

// missed shot icon
	timelineLegend.append("circle")
		.attr("class","shotIcon shotIconMiss shotIconFocalTeam")
		.attr("cx", 0)
		.attr("cy", 0)
		.attr("r", 4); // change to 6 if want to reflect focal player

    timelineLegend.append("text")
		.attr("transform",
		  `translate(${timelineLegendHorizSpace}, ${timelineLegendVertStart})`)
		.attr("dy","2em")
		.style("text-anchor", "middle")
		.text(" shot - missed");

    // goal icon
    timelineLegend.append("circle")
		.attr("class","shotIcon shotIconFocalTeam")
		.attr("cx", 0)
		.attr("cy", timelineLegendVertSpace)
		.attr("r", 4); // change to 6 if want to reflect focal player

    timelineLegend.append("text")
		.attr("transform",`translate(${timelineLegendHorizSpace}, ${timelineLegendVertStart+1*timelineLegendVertSpace})`)
		.attr("dy","2em")
		.style("text-anchor", "middle")
		.text(" shot - scored");

    // Score area plots, for legend
    const areaWinLegData = [{"x":"0", "y":"-10"},
        {"x":"10", "y":"-15"},
        {"x":"20", "y":"-15"}
      ];

    var areaWinLeg = d3.area()
		.curve(d3.curveStepAfter)
		.x( function(d) { return d.x; } )
		.y0(0)
		.y1( function(d) { return d.y; } );

     timelineLegend.append("path")
      .datum(areaWinLegData)
      .attr("class","areaWin")
      .attr("d", areaWinLeg)
      .attr("transform",
        `translate(-10, ${timelineLegendVertStart+4*timelineLegendVertSpace})`);

      const areaLoseLegData = [{"x":"0", "y":"5"},
          {"x":"5", "y":"10"},
          {"x":"20", "y":"10"}
        ];

      var areaLoseLeg = d3.area()
        .curve(d3.curveStepAfter)
        .x( function(d) { return d.x; } )
        .y0(0)
        .y1( function(d) { return d.y; } );

		timelineLegend.append("path")
        .datum(areaLoseLegData)
        .attr("class","areaLose")
        .attr("d", areaLoseLeg)
        .attr("transform",
          `translate(-10, ${5+timelineLegendVertStart+4*timelineLegendVertSpace})`);

		timelineLegend.append("text")
          // .attr("class","axisLabel")
		.attr("transform",
		`translate(${2+timelineLegendHorizSpace}, ${timelineLegendVertStart+3*timelineLegendVertSpace - 7})`)
		.attr("dy","2em")
		.style("text-anchor", "middle")
		.text("team 1 score");

        timelineLegend.append("text")
            // .attr("class","axisLabel")
            .attr("transform",
              `translate(${2 + timelineLegendHorizSpace}, ${timelineLegendVertStart+3*timelineLegendVertSpace + 10})`)
            .attr("dy","2em")
            .style("text-anchor", "middle")
            .text("team 2 score");


	for(var nn=0; nn<6; nn++) {
		gameNum = nn+1;

		var timeline = timelineGroup.append("g")
			.attr("class","timeline")
			.attr("transform", `translate(0, ${(gameNum-1)*(timelineHeight+timelineVerticalPadding)})`)
			.attr("opacity",(gameFilter[nn]?1:.25))
			.on("click", (function makeClickFunction(num) {
				return (function() {
						gameFilter[num] = !gameFilter[num];
						timelines[num]
							.attr("opacity",(gameFilter[num]?1:.25));
						populateScatterPlots();
					})
				})(nn));
		timelines[nn] = timeline;
		quarters[nn] = [];

		timeline.append("rect")
			.attr("class","backdrop")
			.attr("x",0)
			.attr("y",0)
			.attr("width",timelineWidth)
			.attr("height",timelineHeight)
			.attr("fill",'white');

		var lineLength = 80;
    // Add game number to the timelines
    timeline.append("text")
		.attr("class","axisLabel")
		.attr("y",timelineHeight/1.5)
		.attr("x",-timelineInternalPadding - lineLength)
		.attr("dy","-.2em")
		.style("text-anchor", "middle")
		.text(gameNum);
		/*
		  Add flags and team names
		*/
		// first, USA
		timeline.append("text")
			.attr("class","teamnameThis")
			.attr("y",timelineHeight/2)
			.attr("x",-timelineInternalPadding-lineLength/4)
			.attr("dy","-.2em")
			.style("text-anchor", "middle")
			.text("?");
		timeline.append("image")
			.attr("class","flagThis")
			.attr("href", imgPath + currTeamCode + ".png")
			.attr("y", timelineHeight/1.95-20)
			.attr("x",-timelineInternalPadding-lineLength*.9)
			.attr("height", "20px");

		// now add the other team
		timeline.append("text")
			.attr("class","teamnameOpponent")
			.attr("y",timelineHeight/2)
			.attr("x",-timelineInternalPadding-lineLength/4)
			.attr("dy", "1.2em")
			.style("text-anchor", "middle")
			.text("?");
		timeline.append("image")
			.attr("class","flagOpponent")
			.attr("href", imgPath + currTeamCode + ".png")
			.attr("y", timelineHeight/1.95)
			.attr("x",-timelineInternalPadding-lineLength*.9)
			.attr("height", "20px");
		timeline.append("line")
			.attr("style","shape-rendering: crispEdges")
			.attr("x1",-timelineInternalPadding)
			.attr("x2",-timelineInternalPadding-lineLength*.9)
			.attr("y1",timelineHeight/2+1)
			.attr("y2",timelineHeight/2+1)
			.attr("stroke","black")
			.attr("stroke-width",1);

		// Final scores
		timeline.append("text")
			.attr("class","finalScoreThis")
			.attr("y",timelineHeight/2)
			.attr("x",timelineWidth+timelineInternalPadding)
			.attr("dy","-.4em")
			.style("text-anchor", "middle")
			.text("?");
			//.text(endingScore[0]);
		timeline.append("text")
			.attr("class","finalScoreOpponent")
			.attr("y",timelineHeight/2)
			.attr("x",timelineWidth+timelineInternalPadding)
			.attr("dy", "1.2em")
			.style("text-anchor", "middle")
			.text("?");
			//.text(endingScore[1]);

		for(var quarterNum=1; quarterNum <= 4; quarterNum++) {
			//console.log("Quarter:"+quarterNum);

	// persistent elements

			// Add timeline for this quarter
			var quarter = timeline.append("g")
				.attr("class","quarter")
				.attr("width", timelineQuarterWidth)
				.attr("height", timelineHeight)
				.attr("transform", `translate(${(timelineQuarterWidth+timelineInternalPadding)*(quarterNum-1)}, 0)`);
			quarters[nn].push(quarter);
			// Axis
			quarter.append("g")
				.attr("class", "axis axis--x")
				.attr("transform", `translate(0, ${timelineHeight/2})`)
				.call(d3.axisBottom(quarterTime).ticks(0).tickSizeOuter(0));

			var scoreLineWin = quarter.append("path")
				.attr("class", "areaWin");

			var scoreLineLose = quarter.append("path")
				.attr("class", "areaLose");
		}
	}
}

function populateTimelines() {
//console.clear();


for(var nn=0; nn<6; nn++) {
	var timeline = timelines[nn];


	gameNum = nn+1;
	var gameNData = poloData.filter(isGameN);
	//console.log(JSON.stringify(poloData).replace(/},{/g,"},\n\n{"));
	function isGameN(d) {
		return (d.Game===gameNum);
	}

	if(gameNData.length==0) { // There is no n-th game; kill chart

		timeline.selectAll(".flagThis")
			.attr("href", imgPath + "BLANK" + ".png");
		timeline.selectAll(".flagOpponent")
			.attr("href", imgPath + "BLANK" + ".png");

		timeline.selectAll(".teamnameThis")
			.text("");
		timeline.selectAll(".teamnameOpponent")
			.text("");
		for(var quarterNum=1; quarterNum <= 4; quarterNum++) {

			//console.log("\n\nQuarter: "+quarterNum);
			var quarter = quarters[nn][quarterNum-1];
			var dots = quarter.selectAll(".shotIcon")
				.data(gameNData);
				dots.exit()
					.remove();

			var areaWin = d3.area()
				.curve(d3.curveStepAfter)
				.x(0)
				.y0(0)
				.y1(0);

			var areaLose = d3.area()
				.curve(d3.curveStepAfter)
				.x(0)
				.y0(0)
				.y1(0);

			var scoreLineWin = quarter.selectAll(".areaWin")
				.data([{}])
				.attr("d", areaWin);

			var scoreLineLose = quarter.selectAll(".areaLose")
				.data([{}])
				.attr("d", areaLose);

			}
			timeline.selectAll(".finalScoreThis")
				.text("");
			timeline.selectAll(".finalScoreOpponent")
				.text("");
			continue; // do not proceed further, exit iteration of loop
	}

	var otherTeam = gameNData[0]["Opponent name"];
	//console.log(gameNData.length);

	// set flags, names on left
	timeline.selectAll(".flagThis")
		.attr("href", imgPath + currTeamCode + ".png");
	timeline.selectAll(".flagOpponent")
		.attr("href", imgPath + otherTeam + ".png");

	timeline.selectAll(".teamnameThis")
		.text(currTeamCode);
	timeline.selectAll(".teamnameOpponent")
		.text(otherTeam);

	var maxScore = d3.max(poloData, (d) => {
		if(d.Game===gameNum) {
			//return Math.abs(d[currTeamCode] - d.Opponent);
			return Math.max(d[currTeamCode], d.Opponent);
		} else {
			return 0;
		}
	});
	var beginningScore = [0,0];
	var endingScore = [0,0];
	for(var quarterNum=1; quarterNum <= 4; quarterNum++) {
		//console.log("\n\nQuarter: "+quarterNum);
		var quarter = quarters[nn][quarterNum-1];

		// Data-dependent elements

		var gameNData = poloData.filter(isGameN);
		//console.log(JSON.stringify(gameNData).replace(/},{/g,"},\n\n{"));
		function isGameN(d) {
			return (d.Game===gameNum && d.Period===quarterNum);
		}
		var myGoals = poloData.filter( (d) => {
			return d.Game===gameNum && d.Period===quarterNum && d.Goal===1;
		}).sort( (d1,d2) => { return d2.Seconds-d1.Seconds; });
		//console.log(JSON.stringify(myGoals).replace(/},{/g,"},\n\n{"));

		function getScoreAtLastGoal(min,d) {
			//console.log(JSON.stringify(d));
			//console.log(currTeamCode+":"+[d[currTeamCode],d.Opponent]);
			if(d.Seconds < min[0]) {
				return [d.Seconds,[d[currTeamCode],d.Opponent]];
			} else {
				return min;
			}
		}
		//console.log(JSON.stringify(myGoals).replace(/},{/g,"},\n\n{"));
		//console.log("Beginning score: "+beginningScore);
		endingScore = myGoals.reduce(getScoreAtLastGoal,[8*60,beginningScore]);
		//console.log("Ending score: "+endingScore);
		endingScore = endingScore[1];

		myGoals.push({[currTeamCode]:endingScore[0],"Opponent":endingScore[1],"Seconds":0});
		myGoals.unshift({[currTeamCode]:beginningScore[0],"Opponent":beginningScore[1],"Seconds":8*60});

		//console.log(beginningScore+" : "+endingScore);

// Area plots!
		var areaWin = d3.area()
			.curve(d3.curveStepAfter)
			.x( (d) => { return quarterTime(d.Seconds); })
			.y0( (d) => { return success(0); })
			.y1( (d) => { return success(d3.max([(d[currTeamCode])/maxScore,0])); });
			//.y1( (d) => { return success(d3.max([(d[currTeamCode] - d.Opponent)/maxScore,0])); });

		var areaLose = d3.area()
			.curve(d3.curveStepAfter)
			.x( (d) => { return quarterTime(d.Seconds); })
			.y0( (d) => { return success(0); })
			.y1( (d) => { return success(-d3.max([(d.Opponent)/maxScore,0])); });
			//.y1( (d) => { return success(d3.min([(D[currTeamCode] - d.Opponent)/maxScore,0])); });

		var scoreLineWin = quarter.selectAll(".areaWin")
			.data([myGoals])
			.attr("d", areaWin);

		var scoreLineLose = quarter.selectAll(".areaLose")
			.data([myGoals])
			.attr("d", areaLose);


//  Shot icons

        function classNames(d) {
            res = "shotIcon";
            if(playerFilter.includes(d.Player)) {
                res += " shotIconFocalPlayer";
            } else {
                if(d.Team===currTeamCode) {
                    res += " shotIconFocalTeam";
                } else {
                    res += " shotIconOpponentTeam";
                }
            }
            if(d.Goal===0) {
                res += " shotIconMiss";
            }
            return res;
        }

		quarter.selectAll(".shotIcon").remove();
		var dots = quarter.selectAll(".shotIcon")
			.data(gameNData);

		dots.enter()
			.append("circle")
			.attr("class",classNames)
			.attr("cx", (d) => { return quarterTime(d.Seconds); })
			.attr("cy", (d) => {
				var mysign = (d.Team===currTeamCode?1:-1);
				var isGoal = (d.Goal===1);
			return success(mysign*shotIconDisplayLevel);
			})
			.attr("r", (d) => { return (playerFilter.includes(d.Player)?6:4); })
			.on("mouseover", function(d) {
				tooltip.transition()
				.duration(200)
				.style("opacity", 1.0);
				tooltip.html(
          d.Action + ", " + d.Time + "<br>"
          + ' <img style="width:15px;height:9px;" src="img/' +  d.Team + '.png"></img>'
          + " #" + Math.round(d.Cap) + " " + toTitleCase(d.Player)
          // +" (" + d.Team +  ")"
          // + '  <img style="width:15px;height:9px;" src="img/' +  d.Team + '.png"></img>'    // use flag instead of team name
        )
				.style("left", (d3.event.pageX - 5) + "px")
				.style("top", (d3.event.pageY - 50) + "px");
			})
			.on("mouseout", function(d) {
				tooltip.transition()
				.duration(500)
				.style("opacity", 0);
			});

		beginningScore = endingScore;
	}
	//console.log("ending: "+endingScore +";"+endingScore[0]);
	// set final scores on right
	timeline.selectAll(".finalScoreThis")
		.text(endingScore[0]);
	timeline.selectAll(".finalScoreOpponent")
		.text(endingScore[1]);
}
}

}

/**
* Control methods
*/
{
function togglePlayer(playerName) {
	var ind = playerFilter.indexOf(playerName);
	if(ind>-1) {
		playerFilter.splice(ind,1);
	} else {
		playerFilter.push(playerName);
	}
	filterScatterPlots();
	populateTimelines();
}

function switchTeam(newTeam) {
	initializeData(newTeam);

	scatterLegend.select("#legendPicture")
		.attr("href", imgPath + currTeamCode + ".png");

	//console.log(JSON.stringify(poloData).replace(/},{/g,"},\n\n{"));
	drawAll();
}

function drawAll() {
	populateScatterPlots();
	populateTimelines();
}

function init() {
	d3.select("#welcome")
		.transition()
		.delay(1000)
		.duration(1000)
		.style("opacity",0)
		.remove();
	//console.log(JSON.stringify(allPoloDatas[0]).replace(/},{/g,"},\n\n{"));
	//console.log(JSON.stringify(allShotSummaryDatas[0]).replace(/},{/g,"},\n\n{"));
	for(var ii=0; ii<teamCodes.length; ii++) {
		var opt = document.createElement("option");
		opt.text = teamDecodes[teamCodes[ii]];
		teamSelect.add(opt);
	}
	teamSelect.options[0].selected = true;

	initializeScatterCharts();
	initializeTimelines();
	switchTeam(0);
}
}

var teamCodesDupe = teamCodes.slice(0);
function loadFiles() {
	if(teamCodesDupe.length > 0) {
		var myTeamCode = teamCodesDupe.shift();
		d3.json("data_gathering/data/2017/W/processed/"+myTeamCode+"/shots.json", function(error, raw) {
			allPoloDatas.push(raw);
			d3.json("data_gathering/data/2017/W/processed/"+myTeamCode+"/shot_summary.json", function(error, raw) {
				allShotSummaryDatas.push(raw);
				loadFiles();
			});
		});
	} else {
		init();
	}
}
loadFiles();

//setTimeout(init,5000);

teamSelect.addEventListener("change", function() {
	var newTeam = teamSelect.selectedIndex;
	switchTeam(newTeam);
  // console.log("Current team is " + currTeamCode);
});


</script>

  </section>

<section>
    <h2>Design Rationale</h2>
    <p>
      <em>[How did you choose your particular visual encodings and interaction techniques? What alternatives did you consider and how did you arrive at your ultimate choices?]</em>
    </p>
    <p>
      Although water polo statistics are widely kept at the level of national and international competition, they are nearly always presented in tables, and unlike in other sports, few effective visualizations of these statistics have been developed.
      For example, <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3737929/">this paper</a> contains interesting statistic analyses of water polo success based on the <a href="http://www.omegatiming.com/Sport?sport=AQ">Omega Timing data</a> from several FINA World Championships, but lacks any visual representation of its results.
    	Inspired by the baseball statistics example from class, our goal was to build an interactive graphic that allows the viewer to explore the contributions of different players on a team, as well as team-wide patterns.
      For the scope of this assignment, we decided to focus on offensive statistics, i.e. shots attempted (broken down by shot type) and shots scored.
      We visualize tournament data collected by Omega Timing during the 2017 FINA Women's Water Polo World Championships, which includes teams from 16 different countries.
        </p>

        <p>For a given team/country in this tournament, questions that the audience (water polo fans, players, coaches) might want to explore include:
    	<ol>
    	<li>Which players are the top scorers?</li>
    	<li>Which players perform particularly well at a given shot type?</li>
    	<li>How did a particular player perform at the various shot types?</li>
    	<li>How does the team-wide accuracy vary by shot type?</li>
    	<li>How did shots and goals evolve over the course of the game? (For example, are more shots taken when the score is close? Did the winning team build up its lead steadily or finish strong at the end?)</li>
    	</ol>
        </p><p>Each of these questions might be addressed for a given game, or over the course of several games in the tournament. We now explain how our design decisions were guided by these considerations.
        </p>

    <h4>Scatterplots</h4>

    <p>At the top of the dashboard are five scatterplots showing <strong>number of shots taken</strong> vs. <strong>success rate</strong> (i.e. number of goals / number of shots, as a percentage).
      Each dot corresponds to one or more players; dots are sized according to the number of players they represent.
      The purpose of these scatterplots is to easily pick out exceptional players (in terms of high number of shots and/or high succes rate on shots), and to visualize how the team performs at various types of shots.
      For example, we expect to see a high conversion rate for extra player shots (which occur when a major foul is committed and a player is temporarily removed from the game for 20 seconds, giving the other team a 6-on-5 opportunity).
      Similarly, we expect to see a low conversion rate for shots taken more than 5m away from the goal.
      However, different players excel at different types of shots: for example, the centre shots are typically only taken by a small subset of the players on the team, who often have a high success rate at this type of shot.
      With this in mind, we wanted viewers to be able to both "roll up" and "drill down" in terms of shot type, which is why we show plots both for "all shots" and for individual shot types.

      More specific considerations include:
	<ol>
    <li><strong>Small multiples</strong> allow the viewer to easily understand and navigate between multiple plots.
      The "all shots" plot is larger than the others, emphazing that this is the "big picture" plot while the others show specifics. </li>
	<li><strong>Dot size</strong> is used as an encoding for the number of players with a given number of shots and success rate.
    This choice was in response to the fact that with a traditional scatterplot, we saw significant overplotting
    (since the variables we are working with, i.e. number of shots and number of goals, are discrete).
    We experimented with simply lessening the opacity (rather than changing the dot size) to make overplotting more evident,
    but it was difficult to tell how many players were represented in a given dot with this encoding. Dot size better shows where there are significant groups of players coalescing.</li>
	<li>The dots for the chosen team are <strong>blue</strong> both in the scatterplots and in the timelines, reinforcing the fact that these correspond to the same team.
	<li>The <strong>team average bar in brown</strong> shows the team-wide shooting accuracy, providing a reference to identify above-average players.
    It also provides aggregate information that isn't easily obtained from the individual dots. We chose brown becuase it is distinguishable from blue for color-blind viewers.</li>
	<li>The choice to use <strong>percentages</strong> on the y-axis</strong> was motivated by the fact that when we originally plotted the number of goals on the y-axis instead, all of the dots fall below the 45 degree line.
    Percentages fill the plots and make use of  the space more effectively, while also making it easy to pick out which players have high accuracy, as opposed to which players simply take more shots.</li>
	<li><strong>Tooltips</strong> containing player names and number of shots taken vs. made appear when the viewr hovers over a dot in the scatter plot.
    This allows viewers  to obtain more information about outliers in the plots, without the need for cluttering the plots with more information.
    The tooltips fade in and out to make their appearance and disappearance more natural.</li>
    <li>We implemented <strong>transitions</strong> so that when the scatterplot data is updated (due to a change in either the team selected or the games selected),
      the viewer's sense of object permanence isn't violated by a sudden change.
      The brown team average lines move linearly as they update, but the dots themselves fade out and then back in, since they can correspond to completely different groups of players when the data changes.
      (This is true even when the team stays the same, due to our encoding of multiple players with a single, larger dot.)</li>
    </ol>
    </p>


    <h4>Timelines</h4>
	<p>In the lower portion of the dashboard are six timelines, broken up by quarter, which show when all of the shots and goals occurred throughout each game.
    The area plots show the number of goals that each team has at any given time (normalized by the maximum score over the two teams), so that the viewers
    can see how the goals are accumulating over time.

    More specific considerations for the timelines include:
  </p>

	<ol>
    <li>We chose <strong>strip plots</strong> as a way to visualize shot attempts and successes as each game progressed, since this is a time series characterized by a binary variable.
      Empty/filled circles echo the shape of a water polo ball, and correspond to missed/made shots.</li>
    <li>In the timelines as well, we utilize <strong>small multiples</strong> so that comparisons across games can easily be made by the viewer.</li>
    <li>Rather than a single strip plot per game, we chose to <strong>separate them by quarter</strong>. One advantage of this separation is to more easily distinguish playing strategies at the quarterly level.Becuase of the distinct breaks between quarters, visually chunking time in this way is intuitive.
      Shots that occur at the very end of Quarter 1 and the very beginning of Quarter 2, for example, should not be depicted as adjacent in time, since the playing time is not continuous.</li>
	<li>A <strong>blue/red color encoding</strong> for current team selected and their opponent parallels the color choice of the current team in the scatterplots and makes clear the contrast between the two teams.
    This contrast is furthered by having the strip plot of shot events on a shared horizontal time axis but separated vertically.
    We chose blue and red becuase they are easily distinguishable for common forms of color blindness, and because these colors appear frequently in the country flags, which makes for a pleasant visual aesthetic without too many clashing colors.</li>
	<li>To help consolidate information, a <strong>tooltip</strong> is available for each event on the strip plot indicating player name, cap number, and time of event.
    We used the standard timing conventions of the sport: times are kept at the quartery level and count down from 8:00 to 0:00.
    The country flags are added to the tooltips to make it clear which team you are selecting, since the dots appear close together.
    We felt the exact game time is not as important as sequential nature and rough time in quarter, so generally okay to leave out details on the time axis.</li>
    <li>Timlines are grayed out until selected. A nice interactive element here is that <strong>clicking on a timeline</strong> adds that game's data to the scatterplots, along with showing the timeline.</li>
    <li>Finally, the score of the game at the end of the fourth quarter is shown to the right of the timeline.
      One thing to note is that games which appear to end in a tie actually went into a penalty shootout after the fourth quarter.
      We decided for the scope of this assignment, though, to only show shots and goals that occurred during active play.</li>
</ol>
  </section>

  <section>
    <h2>Design &amp; Development Process</h2>
    <p>
      <em>[Add: An overview of your design and development process. Describe how the work was split among the team members. Include a commentary on the development process, including answers to the following questions: Roughly how much time did you spend developing your application (in people-hours)? What aspects took the most time?]</em>
    </p>

	<h4>BRIAN: data wrangling</h4>
	<p>
		The data that powers our visualization is derived from the "Play by play" documents provided by <a href="http://waterpolo.sportresult.com/WCH2017/res.asp">Omega</a>. Corresponding to each game is a pdf file with a table listing important actions taken by players on either team and when the actions were taken. Since a great number of games are catalogued on Omega's website, we wanted to automate as much of the data collection process as possible. We also reasoned that going through the trouble of automating things for this assignment could save us time in the future should we decide to expand upon our visualization for the final project. <br><br>

		Automating the extraction of data from the pdfs proved difficult. Getting this step working smoothly took roughly 12 hours. We used a <a href="https://github.com/chezou/tabula-py">python wrapper</a> of a tool called <a href="http://tabula.technology/">Tabula</a> for pulling the tables from the pdf files. This software was useful because it interfaced nicely with Pandas, but it produced somewhat unpredictable output when the tables in the pdf files continued for more than a page. Transforming the output of Tabula into a standardized set of tables took a condiserable amount of effort. <br><br>

		Additional work had to be done to map the raw tables pulled from the pdf files into something our visualization could use directly. We wrote code to automatically produce files summarizing when shots were taken for each team, files summarizing how many attempts and goals players on the teams made in different games, a list of all the teams that played in a tournament in a given year, and others. To ensure reproducibility and future ease-of-use, the work flow was encapsulated in a comprehensive Make file. Writing and testing this code required around 13 hours.
	</p>

	<h4>ABE: Vega static visualization, flags, team average bars</h4>
	<p>
		The beginning stages of the development process involved choosing to do this assignment in D3 or Vega. We drafted static visualizations in both languages but moved forward only in D3. This visualization took about 3 hours to create.
	</p>

  <h4>BEN: tons of things in D3</h4>
	<p>


  </p>

  <h4>KELLIE: drawing up sketches of our designs, general water polo knowledge, the legend, help with the layout, a good portion of the write-up, misc. other tasks</h4>
	<p>
    Our initial design discussions, plus drawing up sketches of the details of these designs, and making revisions as we went along, totaled about 6 hours.
    Working on the overall layout of the graphic, including placement of the legend, the instructions on the right side, spacing between different items, and color choices, took about 3 hours.
    Putting the legend together took about 5 hours. Miscellaneous other tasks, including getting everything up and running on GitHub pages, and writing up our design rationale, took about 6 hours.
    Of these tasks, the legend was the most time-consuming individual task, largely because of frustrations with understanding D3.
  </p>

  </section>

  <div class="footer">
    <a href="https://cse512-18s.github.io/">CSE 512 Data Visualization</a> -
    <a href="http://www.washington.edu">University of Washington</a>
  </div>

</div>
</body>
</html>
